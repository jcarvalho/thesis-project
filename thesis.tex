\documentclass{llncs}
\usepackage{tikz}
\usepackage[simplified]{pgf-umlcd}
\usepackage{cite}
\usepackage{listings}
\usepackage{paralist}
%
\begin{document}

\title{LongXact: Making Long-Lived Transactions Easier to Develop}

%% Title
\author{Jo\~{a}o Pedro Carvalho}
\institute{T\'{e}cnico de Lisboa/Universidade T\'{e}cnica de Lisboa
\email{joao.pedro.carvalho@ist.utl.pt}}
\maketitle

%% Abstract

\begin{abstract}
Over the past years, Software Transactional Memories have become more
and more popular, growing to be something more than simply a research topic. On top of
that, the concept has been extended to encompass persistence, so
the concept of Persistent Software Transactional Memories was born. In
this thesis, I propose an extension to PSTM's in order to support the
concept of Long-Lived Transactions. Some research on the topic has
been conducted in the field of Database Transactions and Workflow
systems. My thesis is that supporting Long-Lived Transactions should
be done at the infrastructural level on Persistent STM's, so this
paper will describe how those systems can be extended to support
Long-Lived Transactions.
\end{abstract}

%% Intro

\section{Introduction}

For many years, enterprise applications were developed using
two-tiered architectures. In such architectures, there was typically a
mainframe with great computational power.

Long-Lived Transactions were first described in
1981 as ``[..] transactions with lifetimes of a few days or
weeks''\cite{gray1981transaction}. At the time, the author said that the
solution for this 

-- starts here for now --

In this project, I aim at adding support for Long-Lived Transactions
in applications with Rich Domain Models.
Rich Domain Models are ``An object model of the domain that
incorporates both behaviour and data.``, as described by
\cite{fowler2003patterns}, meaning that domain objects hold both their
data and the business logic that manipulates them, as opposed
 to Anemic Domain Model, in which the domain objects simply 
contain data, and the business operations are handled by a separate 
Service layer. Also, in a Rich Domain Model, each domain object
typically has an arbitrarily complex web of associations, multivalued
attributes, inheritance, and other Object Oriented design patterns.

My focus throughout this project will be on applications in which
the Domain Objects are persistent, transactionally updated, and 
handled transparently at an infrastructural level (meaning the
programmer may be mostly unaware of the persistence layer).

\section{Long-Lived Transactions}

In this section I provide a concrete example of a Long-Lived Transaction,
aiming to better explain the concept, and to show how such
transactions can be found among many applications. I then show why it
is difficult for a programmer to implement a Long-Lived Transaction,
attempting to motivate why a new approach is needed.

\subsection{What are Long-Lived Transactions?}
\label{sec:what}

As previously described, Long-Lived Transactions are transactions with
a lifetime larger than a typical database transaction. In order to
better understand this concept, consider the following example, found
in the applications of many education institutions.

\begin{figure}
\centering
\begin{tikzpicture}

\begin{class}[text width=4.5cm]{Course}{0.5,0}
\attribute{name : String}
\attribute{objectives : String}
\attribute{credits : int}
\attribute{bibliography : Publication[]}
\end{class}

\begin{class}[text width=3cm]{Department}{7.5,-0.85}
\end{class}

\association{Department}{}{1}{Course}{}{*}

\end{tikzpicture}

\caption{Sample Domain Model in UML} 
\label{fig:courseDomain}

\end{figure}

In the domain model presented in Figure~\ref{fig:courseDomain}, we
present a simplification of the Course's attributes. A course belongs
to a department, has a name, its objectives, the credits granted upon
completion, and the recommended bibliography. The domain is deemed to
be consistent only if all attributes of Course have a defined value,
and each course must have a department. Each department is responsible
for managing its courses, meaning that it is up to someone who belongs
to the department to start the process of creating new courses.

Note that the creation of a new course should be executed
transactionally, since it is not desired that other users of the
system are able to see a course in an inconsistent state (either not
connected to any departement and/or without all attributes properly defined).

The pseudo-code in Listing~\ref{fig:courseCreation} implements the
business operation of creating a new course. Assume that {\bf
  department} is inferred from the user performing the operation. 

\lstset{language=Java,
basicstyle=\ttfamily,
stepnumber=2,
numbersep=9pt,
tabsize=4,
frame=single,
caption={Pseudo-Code for the
    creation of a new course. A new Course is created, associated with
  its department, and its attributes are filled.},
label={fig:courseCreation},
captionpos=b}
\begin{lstlisting}
Course course = new Course();
department.addCourse(course);
course.setName(name);
course.setObjectives(objectives);
course.setCredits(credits);
course.setBibliography(bibliography);
\end{lstlisting}

There are several ways to implement this operation. I will now
describe two common scenarios for said implementation.

\subsubsection{Business Transaction in a single interaction}

A possible implementation (most likely, the simplest) of the course
creation operation in a web application is to have a single page in
which the user provides all the required information. Once the
information is submitted, a new Course is created, associated with the
department of the person performing the operation, and all its
attributes are filled according to the information submitted by the
user. The new object is then stored in the database, making it
persistent and available for other users to view.

In this scenario, in which all the information can be provided in a
single user interaction, the transactional guarantees of the operation are
assured by the underlying database (which is assumed to provide the
classic transactional semantics \cite{gray1981transaction}), since the
whole operation can be performed within the scope of a single database
transaction.

An important consequence of implementing the operation in a single
database transaction is that the programmer can manipulate all the domain
objects involved directly. The order in which the modifications to
said objects are performed is irrelevant, as long as the domain is
consistent when the transactions is committed. This is the semantics
typically expected by a programmer of such applications: there may be
instants in which some domain objects are in an inconsistent state
(e.g. before defining the course's bibliography), however this
inconsistent state will never be seen by the other users of the
application. Those users will only see the fully created object once
the operation is committed.

\subsubsection{Business Transaction across multiple interactions}

The model described in the previous scenario, while simple and easy to
implement, may not be suited for every situation. Imagine that instead
of four attributes, Course had 50 attributes. It would then be
unfeasible to ask the user to fill everything out in a single web
page, so the logical solution would be to split the various attributes
in multiple pages, accounting for multiple interactions.

Let us now assume that the creation of a course is made throughout
three interactions. In the first interaction, the user selects the
course's name, in the second interaction, the user introduces the
objectives and credits, and in the final interaction, the user selects
the bibliography, thus creating the course.

At first glance, it would seem quite easy for a programmer to change
the logic programmed in the first scenario, in order to meet the new
requirements: the programmer would simply have to split the code
performed in a single request into three smaller parts, one to be
executed in each request.

However, having three separate requests implies three different
database transactions, breaking the atomicity and isolation of the
operation. After handling the first request, the persisted domain
would be in an inconsistent state (a course with no attributes but its
name).

The implementation of the business logic must then take this issue
into account, since the programmer cannot write the updates directly
on the domain, requiring manual handling.

This scenario represents what was defined as a Long-Lived Transaction,
in which the Business Operation had a larger lifetime that a single
database transaction (in this particular case, three database transactions).

\subsection{Why are they difficult to implement?}

In this multiple interaction scenario, special care must be taken when
implementing the operation. Like mentioned above, one cannot simple
split the code used in the first scenario.

The programmer has then several choices for the implementation:

\begin{enumerate}
\item Keeping a database transaction open during all the steps of the
  operation

\item Create a parallel representation of the objects that are being
  manipulated, store them outside the domain, and applying the changes
  only in the last interaction

\item Change the domain model, to represent the consistency state of
  the objects being manipulated. This affects the code that operates
  on that portion of the domain, since it must filter objects that are
  still in an inconsistent state
\end{enumerate}

It should be clear that any of those solutions is far from trivial,
has some serious consequences, and is an unnecessary burden to the
programmer. 

\subsubsection{Keeping a database transaction open}

Given that atomicity and isolation are broken due to the fact that
each interaction with the user is done within its own database
transaction, one could think the solution would be to keep the
database transaction open during the whole business transaction.

This approach has several disadvantages, due to the fact that 

\subsubsection{Parallel Representation of the domain}

In this approach, a series of objects similar to the domain objects
are created, and must be managed manually, kept in the user's session
context, outside the domain.

As the complexity of the domain, and the number of objects the
operation affects grow, the harder it becomes for the programmer to
manually. Ultimately, there is a copy of the whole of the domain
stored in the user's session, waiting for the last transaction to copy
all the information back to the domain transactionally.

This is the opposite of what would be desirable to the programmer, she
should be able to operate directly on the domain.

\subsubsection{Changing the domain model}

Now imagine that an additional requirement is added to the system: the
user may be allowed to log off in the middle of the process, and when
logging back in and continue the work where he left off. Additionally,
anyone else in the user's department should be able to pick up where
the original user left off. With these requirements, it becomes clear
that simply storing a copy of the domain in session-local storage is
not enough. 

Web application containers already provide an application context,
which could potentially solve this issue, however, there are no real
guarantees that the data stored in that context will be kept for an
arbitrarily large period of time (recall that our transaction may span
several days or weeks), meaning that the intermediate data must be
kept persistently, forcing the programmer to be concerned with this
issue.

A possible solution for this requirement is to change our domain
model, by adding a new attribute to the objects being modified (in
this case, Course, as shown in
Figure~\ref{fig:courseDomainState}). The {\bf status} attribute
indicates whether the course is in a consistent state (Published) or
not (Draft). Adding this attribute has a cost, not only the domain is
'polluted' with information that is not relevant to the object being
modeled, but has impact on other functional code across the
application, since course listings must filter out courses that are
still in the Draft status, scattering the filtering code throughout
the application.

\begin{figure}
\centering
\begin{tikzpicture}

\begin{class}[text width=4.5cm]{Course}{0.5,0}
\attribute{name : String}
\attribute{objectives : String}
\attribute{credits : int}
\attribute{bibliography : Publication[]}
\attribute{status : \{Draft, Published\}}
\end{class}

\begin{class}[text width=3cm]{Department}{7.5,-1}
\end{class}

\association{Department}{}{1}{Course}{}{*}

\end{tikzpicture}

\caption{Domain Model with state representation} 
\label{fig:courseDomainState}

\end{figure}

\subsubsection{Other approaches}

There are other approaches to Long-Lived Transactions, such as using
the Database. There are some DBMSs that announce support for
Long-Lived Transactions, such as Oracle's Workspace Manager. However,
such support is not standardized, their API's are proprietary,
rendering Web frameworks unusable in those cases (since they generally 
support only the SQL standard), forcing the application to be written
against the proprietary API, making it very hard to change and
maintain. All these factors contribute to make this approach inadmissible for
most cases.

\subsection{Applications of LLTs}

Even though the example I just presented was targeted at a system with
a rich domain model, there are several other applications of
Long-Lived Transactions.

\subsubsection{Database Management Systems}

The example provided above is targeted at applications with a rich
domain model, however 

\subsubsection{Workflow Systems}

Workflow Management Systems are another area in which Long-Lived
Transactions are interesting. Workflow processes are inherently
Long-Lived. Each activity can be seen as an interaction in the example
presented above.

\subsection{Objectives}

All this effort makes Long-Lived Transactions a concept that is very
hard to implement, promotes bad software engineering practices
(replication, code scattering, etc), and is
difficult to reason about. My thesis is that the support for
Long-Lived Transactions should be transparent, and at an
infrastructural level, relieving the programmer from this burden.

\section{Related Work}

In this section I describe the various topics in which an attempt to
solve the problem of Long Lived Transactions has been made, namely
Database Management Systems, Workflow Systems and Object Oriented
Transactional Systems.

Also, due to its relevance regarding the
solution described in section 4, I briefly present Software
Transactional Memories, and how they cope with short lived transactions.

\subsection{Database world}

*Mention classic books*

*Mention Martin Fowler's patterns \cite{fowler2003patterns}*

*Relaxation of transactional properties*

*Several Papers: \cite{hagmann1991implementing} \cite{garcia1987sagas}
\cite{salem1989altruistic}

*Talk about isolation levels*

*Mention that the best implementations of LLT's at the database level
provide only Serializability at best*

\subsection{Workflow Management Systems}

\cite{alonso1996advanced}

*Sagas* \cite{garcia1987sagas}

\cite{798492}

*Compensations*

*Exception Handling systems*

*Explain why those solutions are not good, since they *may* break ACI
of the ACID model*

\subsection{Object-Relational Mappings}

*Talk about how ORM's handle transactions, i.e. Hibernate*

\subsection{Object-Oriented}

*Talk about ORM's in Object Oriented systems, such as Hibernate*

*Talk about the Fenix Framework, how it implements a Persistent STM,
mention that the Framework brings Strict Serializability to a
'transparent' programming model* \cite{fernandes2011strict} 
\cite{guerraoui2008correctness} \cite{cachopo2006versioned}

*Talk about how this project aims at extending the FF model to support LLT's*

\subsection{STM's}
\label{sec:stm}


\section{Solution Architecture}

In this section I will describe the architecture of my proposed
solution, as well as a small introduction to the Fenix Framework
\cite{fernandes2011strict}, in which it will be implemented.

\subsection{Transactional Contexts}

The main goal of this solution is to relieve programmers of the burden
of dealing with Long-Lived Transactions, making the effort needed to
program one similar to the effort of programming a regular
transaction. So, what does the single interaction scenario has that
makes it so easy to program? It has a single transactional context
that spans the whole operation (provided by the database transaction,
given that they have the same lifespan). In the second scenario the
database transaction was shorter than the whole operation, so the
context was lost in each step.

The main concept of the proposed architecture is then the {\bf
  Transactional Context}. It is represented as a first-class domain entity in our
rich domain model, making it persistent (unlike the context provided
by a single database transaction) and transactional. With this
persistent context, the programmer no longer needs to rely on the
database to provide the transactional semantics of the operation. 

\begin{figure}
\centering
\begin{tikzpicture}

\begin{class}[text width=4cm]{TransactionalContext}{0,0}
\end{class}

\begin{class}[text width=1.2cm,minimum height=5em]{Log}{4,-2}
\end{class}

\begin{abstractclass}[text width=3cm]{DomainObject}{8,0}
\end{abstractclass}

\draw[umlcd style school] (DomainObject) |-node[below, sloped,
black]{object} (Log);

\draw[umlcd style school] (DomainObject) -| node[above, black]
{value} (Log);

\draw[umlcd style school] (TransactionalContext) |- node[below, black]
{readSet} (Log);

\draw[umlcd style school] (TransactionalContext) --
node[near start, above, black]{1} (Log) 
node[near end, below, black]{1};
\end{tikzpicture}

\caption{Transactional Context} 
\label{fig:transactionalContext}

\end{figure}

Figure~\ref{fig:transactionalContext} presents the conceptual model of the
Transactional Context. Since it is a first-class entity, it can be
manipulated just like any other domain object. Its purpose is to keep
all the changes made to the domain objects during the transaction,
keeping those changes isolated from code executing outside this
context.

The Transactional Context has two sets of {\bf Log}s representing both
the read set and the write set of the transaction. A Log contains a
reference to the original object it refers to, and a
Transactional-Local copy of the value of the object. In case of a Log
for a read operation, the value is a snapshot of the object when it
was first read. In the Log for a write operation, the log will retain
the value being written.

Any read operation will read the value stored in the Log for that
particular object (whether it has been modified outside the context or
not), or create a new Log entry if it's the first time
the object is being accessed. A write operation will behave similarly,
writing the new value to. It is important to note that there is at
most one Log entry per object. When a write to an object that has been
previously read occurs, its corresponding Log entry is promoted from
the Read Set to the Write Set.

Collaboration from the methods that get/set values of the domain
objects is required, since those methods must be aware of the presence
of the transactional context. Depending on whether the method performs
a read or write operation, it must access the corresponding Log of the
current context in order to read/modify the snapshot/copy of the
object's attributes.

Transactional contexts can be either aborted or committed. Aborting a
transactional context simply discards all associated Log entries,
while committing atomically merges the Write Set with the domain. This
operation must obey to the same consistency rules as any regular
transaction, all objects in both Sets must be in a consistent state
with the objects outside the context.

\subsection{Fenix Framework}

STMs, PSTMs, DML

\ref{sec:stm}

Describe that the solution will be build on top of the Fenix Framework
core, plus JVSTM, making it agnostic to the specific persistence
backend in use. 



\subsection{Programming Model}

The previously presented concept of Transactional Context as the basic
building blocks for Long-Lived Transactions. However, Transactional
Contexts are not business operations.

The main idea is that every business operation that has transactional
requirements should execute within a transactional context. But due to
the fact that the operation may have several steps, one must keep
track of Transactional Context, so it is used in all steps of the
operation. 

Since keeping track of the context can be cumbersome, and should be
done transparently, a new concept is introduced: {\bf Transactional
  Business Operation} (TBO). As shown in Figure~\ref{fig:TBO}, a TBO
not only is a first-class entity that represents a particular business
operation, but also holds its transactional context. The TBO is then
responsible for 
\begin{inparaenum}[\itshape 1\upshape)]
\item Managing the life-cycle of the Transactional Context
\item Ensuring that the several steps of the operation execute within
  the operation's context.
\end{inparaenum}

\begin{figure}
\centering
\begin{tikzpicture}

\begin{abstractclass}[text width=6cm]{TransactionalBusinessOperation}{0,0}
\operation{end() : void}
\operation{abort() : void}
\end{abstractclass}

\begin{class}[text width=4cm]{TransactionalContext}{7,-0.7}
\end{class}

\association{TransactionalBusinessOperation}{context}{}{TransactionalContext}{}{}

\end{tikzpicture}

\caption{Transactional Business Operation} 
\label{fig:TBO}

\end{figure}

criação do TBO, gestão do life-cycle, exemplo do Get/set do TC

obtenção do TBO

Due to this fact, Transactional Contexts may be seen as 'Low-Level'
API, while Transactional Business Operations may be seen as the
'High-Level' API.

\lstset{language=Java,frame=single,caption={Sample
  implementation of a method that runs inside a Long Lived
  Transaction}}
\begin{lstlisting}

public CourseCreation(Department department) {
  this.setDepartment(department);
  this.setNewCourse(new Course());
  department.addCourse(this.getNewCourse());
}

@Step
public void createNewCourse(String courseName) {
  this.getNewCourse().setName(courseName);
}

@Step(last = true)
public void setBibliography
(Publication[] bibliography) {
  this.getNewCourse().setBibliography(bibliography);
}
\end{lstlisting}

\section{Evaluation}

The final evaluation of this project will be measured in terms of:
- Programmer effort needed to use LLT's
- Performance, throughput, Commit/Abort ratios, interleaving LLTs with
'regular' transactions

\section{Conclusion}

\bibliography{thesis.bib}
\bibliographystyle{plain}
\end{document}
